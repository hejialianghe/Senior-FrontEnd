## 1. javaScript内存管理

### 1.1 js内存机制

🔥内存空间：栈内存（stack）、堆内存（heap）

1. 栈内存：所有原始数据类型都存储在栈内存中，如果删除一个栈原始数据，遵循先进后出；如下图：a最先进栈，最后出栈。
![](~@/jsasvanced/stack.png)

2. 堆内存：引用数据类型会在堆内存中开辟一个空间，并且会有一个十六进制的内存地址，在栈内存中声明的变量的值就是十六进制的内存地址。

![](~@/jsasvanced/heap.png)

 函数也是引用数据类型，我们定一个函数的时候，会在堆内存中开辟空间，会以字符串的形式存储到堆内存中去，如下图：
 
 ![](~@/jsasvanced/function.png)

 ```javascript
 // 我们直接打印fn会出现一段字符窜
 console.log(fn)
  f fn() {
      var t=10;
      var f=10;
      console.log(i+j)
  }
  // 加上括号才执行里面的代码
  fn() // 20
  ```
 
### 1.2 垃圾回收
 🔥概念：（我们平时创建所有的数据类型都需要内存）
   所谓的垃圾回收就是找出那些不再继续使用的变量，然后释放出其所占用的内存，垃圾回收会按照固定的时间间隔周期性的执行这一操作。

 🔥javaScript使用的垃圾回收机制来自动管理内存，垃圾回收是把双刃剑；垃圾回收是不可见的

  -  优势：可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄漏问题。

  - 不足：程序员无法掌控内存，javascript没有暴露任何关于内存的api，无法强迫进行垃圾回收，无法干预内存管理。

🔥 垃圾回收的方式

1. 引用计数（reference counting）

      跟踪记录每个值被引用的次数，如果一个值引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放

      原理：每次引用加1，被释放减1，当这个值的引用次数变成0时，就将其内存空间释放。
 ```javascript
    let obj= {a:10}; // 引用+1
    let obj1={a:10} // 引用+1
    obj ={} //引用减1
    obj1=null //引用为0
 ``` 
引用计数的bug：循环引用
  ```javascript
    // ie8较早的浏览器,现在浏览器不会出现这个问题
    function Fn (){
        var objA={a:10}
        var objB={b:10}
        objA.c=objB
        objB.c=objA
    }
 ``` 
 2. 标记清除（现代浏览采用标记清除的方式）

 🔥概念：标记清除指的是当变量进入环境时，这个变量标记为“进入环境”;而当变量离开环境时，则将其标记为“离开环境”，最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间（所谓的环境就是执行环境）
 
 🔥全局执行环境
   - 最外围的执行环境
   - 根据宿主环境的不同表示的执行环境的对象也不一样，在浏览器中全局执行环境被认为是window对象
   - 全局变量和函数都是作为window对象的属性和方法创建的
   - 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境只有当关闭网页的时候才会被销毁）

  🔥环境栈（局部）
  - 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之浅的执行环境，ECMAScript程序中的执行流正式由这个方便的机制控制着
 
```javascript
    function foo (){
       var a = 10   // 被标记进入执行环境
       var b = ‘hello’ // 被标记进入执行环境
    }
    foo()  //执行完毕，a 和 b 被标记离开执行环境，内存被回收
```
### 1.3 V8内存管理机制

  🔥V8引擎限制内存的原因
   - V8最初为浏览器设计，不太可能遇到大量内存的使用场景（表层原因）
   - 防止因为垃圾回收所导致的线程暂停执行的时间过长（深层原因，按照官方的说法以1.5G的垃圾回收为例，v8做一次小的垃圾回收需要50毫秒以上，做一次非增量的垃圾回收需要1秒以上，这里的时间是指javascript线程暂停执行的时间，这是不可接受的，
   v8直接限制了内存的大小，如果说在node.js中操作大内存的对象，可以通过去修改设置去完成，或者是避开这种限制，1.7g是在v8引擎方面做的限制，我们可以使用buffer对象，而buffer对象的内存分配是在c++层面进行的，c++的内存不受v8的限制）

  🔥V8回收策略
   - v8采用可一种分代回收的策略，将内存分为两个生代；新生代和老生代
   - v8分别对新生代和老生代使用不同的来及回收算法来提升垃圾回收效率

  🔥新生代垃圾回收
  from和to组成一个`Semispace`（半空间）当我们分配对象时，先在from对象中进行分配，当垃圾回收运行时先检查from中的对象，当`obj2`需要回收时将其留在from空间，而`ob1`分配到to空间，然后进行反转，将from空间和to空间进行互换，进行垃圾
  回收时，将to空间的内存进行释放，简而言之from空间存放不被释放的对象，to空间存放被释放的对象，当垃圾回收时将to空间的对象全部进行回收
  ![](~@/jsasvanced/v8.jpg)

  🔥新生代对象的晋升（新生代中用来存放，生命较短的对象，老生代存放生命较长的对象）
   - 在新生代垃圾回收的过程中，当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采取新的算法进行管理
   - 在From空间和To空间进行反转的过程中，如果To空间中的使用量已经超过了25%，那么就将From中的对象直接晋升到老生代内存空间中

  🔥老生代垃圾回收（有2种回收方法）
   - 老生代内存空间是一个连续的结构
  ![](~@/jsasvanced/oldshengdai.jpg)
  1. 标记清除（Mark Sweep）
  Mark Sweep 是将需要被回收的对象进行标记，在垃圾回收运行时直接释放相应的地址空间,红色的区域就是需要被回收的
  ![](~@/jsasvanced/marksweep.jpg)
  - 标记合并（Mark Compact）
  Mark Compact将存活的对象移动到一边，将需要被回收的对象移动到另一边，然后对需要被回收的对象区域进行整体的垃圾回收
  ![](~@/jsasvanced/markconpact.jpg)
  

## 2. 如何保证你的代码质量







## 3. 提高代码的可靠性